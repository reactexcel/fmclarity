/**
 * @author          Leo Keith <leo@fmclarity.com>
 * @copyright       2016 FM Clarity Pty Ltd.
 */

import CloseDetailsSchema from './CloseDetailsSchema.jsx';
import RequestLocationSchema from './RequestLocationSchema.jsx';
import RequestFrequencySchema from './RequestFrequencySchema.jsx';
import IncidentCommentSchema from './IncidentCommentSchema.jsx';

import { Teams } from '/modules/models/Teams';
import { Users } from '/modules/models/Users';
import { Requests } from '/modules/models/Requests';
import { DocExplorer } from '/modules/models/Documents';
import { FileExplorer } from '/modules/models/Files';
import { Facilities, FacilityListTile } from '/modules/models/Facilities';

import { ContactCard } from '/modules/mixins/Members';
import { Text, TextArea, Select, CalendarPeriod, DateTime, Switch, DateInput, FileField, Currency } from '/modules/ui/MaterialInputs';
import AddressSchema from './AddressSchema.jsx'

import React from "react";
import moment from 'moment';
/**
 * @memberOf        module:models/Requests
 */
const defaultContactRole = 'supplier manager';
let onServiceChange = null;

const RequestSchema = {

        //$schema:              "http://json-schema.org/draft-04/schema#",
        //title:                "Request",
        //description:          "A work request",

        //properties:
        //{
        _id: {
            label: "Auto generated document id",
            description: "Document id generated by Mongo",
            type: "string",
            input: Text,
            options: {
                readonly: true
            },
            defaultValue: () => {
                return Random.id();
            }
        },

        name: {
            label: "Summary",
            type: "string",
            required: true,
            maxLength: 90,
            input: Text,
            description: (item)=>{
                let workRequest = "work request";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type + " details"
                }
                return "A brief, descriptive, title for the " + workRequest;
            }
        },

        code: {
            label: "Code",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The unique code for this"+ workRequest +"request";
            },
            type: "number",
            input: Text,
            defaultValue: getJobCode,
            options: {
                readonly: true
            }
        },

        type: {
            label: "Request type",
            description: "The work request type (ie Ad-hoc, Preventative)",
            type: "string",
            size: 12,
            required: true,
            defaultValue: () => {
                let team = Session.get( 'selectedTeam' );
                if ( Teams.isServiceTeam( team ) ) {
                    return 'Tenancy';
                }
                return "Ad-hoc";
            },
            input: Select,
            options: (item) => {
                let role = Meteor.user().getRole(),
                    team = Session.get( 'selectedTeam' ),
                    user = Meteor.user();

                if ( Teams.isServiceTeam( team ) ) {
                    return {
                        items: [ 'Base Building', 'Preventative', 'Defect', 'Reminder', 'Incident' ],
                        afterChange: ( request ) => {
                                // prefill value with zero for defect
                                if (_.contains( [ "Defect", "Incident", "Preventative", "Reminder" ], request.type )) {
                                    request.costThreshold= '0';
                                }
                                if(request.type == 'Incident'){
                                    request.priority = 'Urgent';
                                    request.supplier = Session.getSelectedTeam();
                                }

                                } };
                } else {
                    if ( _.contains( [ "staff", 'resident', 'tenant' ], role ) ) {
                        let items = role=="staff" ? [ 'Ad-hoc', 'Booking' ] : (role=="resident" ? [ 'Ad-hoc', 'Booking', 'Tenancy', 'Key Request' ] : [ 'Ad-hoc', 'Booking', 'Tenancy' ]);
                        return {
                            items: items,
                            afterChange: ( request ) => {
                                // prefill area with tenant/resident address
                                if (_.contains( [ "Tenancy","Key Request" ], request.type )) {
                                    request.area= user.apartment ? user.apartment : null;
                                    request.level= user.level ? user.level : null;
                                }
                                else{
                                    request.area = request.area ? request.area : null;
                                    request.level = request.level ? request.level : null;
                                }

                                }
                             };
                    } else {
                        return { items: [ 'Ad-hoc', 'Booking', 'Preventative', 'Defect', 'Reminder', 'Incident' ],
                                afterChange: ( request ) => {
                                    // prefill value with zero for defect
                                    if (_.contains( [ 'Defect', 'Preventative' ], request.type )) {
                                        request.costThreshold= '0';
                                        request.frequency = {
                                            number: (request.type == 'Preventative' ? 1 : ""),
                                            repeats: (request.type == 'Preventative' ? 10 : ""),
                                            period: "",
                                            endDate: "",
                                            unit: (request.type == 'Preventative' ? "years" : "")
                                        };
                                    }
                                    if (request.type == 'Reminder') {
                                        request.costThreshold = '0';
                                    }
                                    if(request.type == 'Incident'){
                                        request.costThreshold= '0';
                                        request.priority = 'Urgent';
                                        request.supplier = Session.getSelectedTeam();
                                    }
                                }
                         };
                    }
                }
            }
        },

        priority: {
            label: "Priority",
            description: (item) =>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The urgency of the "+ workRequest +" request";
            },
            type: "string",
            defaultValue: (item) =>{
                let priority = "Standard";
                if(item.type == 'Incident'){
                    priority = 'Urgent'
                }
                return priority;
            },
            required: true,
            condition: ( request ) => {
                if ( request.type == "Preventative" || request.type == 'Booking' ) {
                    return false;
                }
                return true;
            },
            input: Select,
            size: 6,
            options: ( item ) => {
                return ( {
                    items: [
                        "Standard",
                        "Scheduled",
                        "Urgent",
                        "Critical"
                    ],
                    afterChange: ( item ) => {
                        let timeframe, dueDate;
                        if ( item.team && item.priority ) {
                            timeframe = getTimeframe( item.team._id, item.priority );
                            timeframe *= 1000;
                            dueDate = ( ( ( new Date() ).getTime() ) + timeframe );
                            item.dueDate = new Date( dueDate );
                        }
                    }
                } )
            }
        },

        frequency: {
            /*label: "Frequency",
            description: "The frequency with which this job should occur",*/
            condition: "Preventative",
            subschema: RequestFrequencySchema,
            required: true,
            type: "object",
        },

        duration: {
            label: "Duration",
            type: "string",
            input: Text,
            size: 6,
            required: true,
            condition: "Booking"
        },

        status: {

            label: "Status",
            description: "The current status of the job",
            type: "string",
            input: Select,
            readonly: true,
            defaultValue: "Draft",
            /*() => {
                        let role = Meteor.apply( 'User.getRole', [], { returnStubValue: true } );
                        return _.indexOf( [ "portfolio manager", "manager" ], role ) > -1 ? "New" : "Draft";
                    },*/

            options: {
                items: [
                    'Draft',
                    'New',
                    'Approved',
                    'Accepted',
                    'Quoting',
                    'Complete',
                    'Closed'
                ]
            }
        },

        //////////////////////////////////////////////////
        // Facility dependant properties
        //////////////////////////////////////////////////
        location: {
            label: "Where did it happen?",
            type: "string",
            input: Text,
            size: 6,
            required: true,
            condition: "Incident"
        },
        incidentVictim: {
            label: "Who did it happen to?",
            type: "string",
            input: Text,
            size: 6,
            required: true,
            condition: "Incident"
        },
        reporter: {
            label: "Reporter",
            description: "Who reported the incident",
            type: "object",
            input: Select,
            required: true,
            options: ( request ) => {
                    request = Requests.collection._transform( request );

                    let team = request.getFacility() || request.getTeam(),
                        members = team.getMembers();
                    return {
                        items: members,
                        view: ContactCard
                    }
            },
            condition: "Incident"
        },
        reporterContact: {
            label: "Reporter Contact ",
            type: "string",
            input: TextArea,
            size: 6,
            required: true,
            condition: "Incident"
        },
        incidentFurtherComments: {
            type: "object",
            subschema: IncidentCommentSchema,
            condition: "Incident"
        },
        level: {
            label: "Location - Area",
            size: 4,
            type: "object",
            input:( props ) => {
                return <Select {...props}
                        onChange={( value ) => {
                            props.item.area = {};
                            props.onChange(value);
                        }}/>
            } ,
            required: true,
            condition: ( item ) => {
                let selectedTeam = Session.get( 'selectedTeam' );
                if (item.type=="Incident") {
                    return false;
                }
                return Teams.isFacilityTeam( selectedTeam ) || !_.isEmpty( item.level );
            },
            options: ( item ) => {
                let facility = null;
                if ( item.facility ) {
                    facility = Facilities.findOne( item.facility._id );
                }
                let areas = []
                if(item.type == "Booking"){
                    let allArea = facility ? facility.areas : []
                    allArea.map( ( area, idx ) => {
                        if(area.data && area.data.areaDetails && area.data.areaDetails.type == "Bookable"){
                            if(_.find(areas, function(obj){ return obj.name == area.name; }) == undefined){
                                areas.push(area)
                            }
                        } else if(area.children && area.children.length > 0){
                            area.children.map(( area2, idx2) => {
                                if(area2.data && area2.data.areaDetails  && area2.data.areaDetails.type == "Bookable"){
                                    if(_.find(areas, function(obj){ return obj.name == area.name; }) == undefined){
                                        areas.push(area)
                                    }
                                } else if(area2.children && area2.children.length > 0){
                                    area2.children.map(( area3, idx3) => {
                                        if(area3.data && area3.data.areaDetails  && area3.data.areaDetails.type == "Bookable"){
                                            if(_.find(areas, function(obj){ return obj.name == area.name; }) == undefined){
                                                areas.push(area)
                                            }
                                        }
                                    })
                                }
                            })
                        }
                    })
                } else {
                    areas = facility ? facility.areas : null
                }
                return {
                    items: areas,
                    readOnly: item.type == 'Key Request',
                }
            },
            defaultValue: (request ) => {
                let user = Meteor.user(), val=null;
                if ( user.profile.tenancy && _.contains( [ 'tenant' ], user.getRole() ) ) {
                    val = user.profile.tenancy;
                }
                if (user.getRole() == 'resident' && request.type == 'Key Request' ) {
                    val = user.apartment;
                }
                return val;
            },
        },

        area: {
            label: "Sub-area",
            size: 4,
            type: "object",
            required: false,
            input:( props ) => {
                return <Select {...props}
                        onChange={( value ) => {
                            props.item.identifier = {};
                            props.onChange(value);
                        }}/>
            } ,
            condition: ( item ) => {
                if(
                    item.type == "Booking"
                    && item.level
                    && item.level.data
                    && item.level.data.areaDetails
                    && item.level.data.areaDetails.type != "Bookable"
                )
                {
                    RequestSchema.area.required = true;
                } else {
                    RequestSchema.area.required = false;
                }
                let selectedTeam = Session.get( 'selectedTeam' ),
                    teamType = null;
                if ( selectedTeam ) {
                    teamType = selectedTeam.type;
                }
                return teamType == 'fm' || !_.isEmpty( item.area );
            },
            options: ( item ) => {
                let subAreas = [];
                if(item.type == "Booking"){
                    let allSubArea = item.level && item.level.children ? item.level.children : []
                    allSubArea.map( ( area, idx ) => {
                        if(area.data && area.data.areaDetails && area.data.areaDetails.type == "Bookable"){
                            if(_.find(subAreas, function(obj){ return obj.name == area.name; }) == undefined){
                                subAreas.push(area)
                            }
                        } else if(area.children && area.children.length > 0){
                            area.children.map(( area2, idx2) => {
                                if(area2.data && area2.data.areaDetails  && area2.data.areaDetails.type == "Bookable"){
                                    if(_.find(subAreas, function(obj){ return obj.name == area.name; }) == undefined){
                                        subAreas.push(area)
                                    }
                                }
                            })
                        }
                    } )
                } else {
                    subAreas = item.level ? item.level.children : null
                }
                return {
                    items: subAreas
                }
            }
        },

        identifier: {
            label: "Identifier",
            description: "Area identifier for the job location (ie classroom number)",
            size: 4,
            type: "object",
            input: Select,
            required:false,
            condition: ( item ) => {
                if(
                    item.type == "Booking"
                    && item.area
                    && item.area.data
                    && item.area.data.areaDetails
                    && item.area.data.areaDetails.type != "Bookable"
                )
                {
                    RequestSchema.identifier.required = true;
                } else {
                    RequestSchema.area.required = false;
                }
                let selectedTeam = Session.get( 'selectedTeam' ),
                    teamType = null;
                if ( selectedTeam ) {
                    teamType = selectedTeam.type;
                }
                return teamType == 'fm' || !_.isEmpty( item.identifier );
            },
            options: ( item ) => {
                let subAreas =[];
                if(item.type == 'Booking'){
                    let allSubArea = item.area && item.area.children ? item.area.children : []
                    allSubArea.map( ( area, idx ) => {
                        if(area.data && area.data.areaDetails && area.data.areaDetails.type == "Bookable"){
                            subAreas.push(area)
                        }
                    })
                } else {
                    subAreas = item.area ? item.area.children : null
                }
                return {
                    items: subAreas
                }
            }
        },

        //////////////////////////////////////////////////

        service: {
            label: "Service",
            description: (item) =>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The category of "+ workRequest +" request";
            },
            size: 6,
            type: "object",
            input:( props ) => {
                return <Select {...props}
                        onChange={( value ) => {
                            let team = Session.getSelectedTeam();
                            let costAbleToIssue = true;
                            if(team.defaultCostThreshold){
                                costAbleToIssue = false;
                                let actualCost = props.item.hasOwnProperty("costThreshold") ? props.item.costThreshold.replace(/,/g, "") : "";
                                    actualCost = _.isEmpty(actualCost) ? 0 : parseFloat(actualCost)
                                costAbleToIssue = actualCost <= team.defaultCostThreshold ? true : false;
                            }
                            onServiceChange = costAbleToIssue == true ? props.changeSubmitText : props.changeSubmitText(null)
                            props.item.occupancy = value && value.data && value.data.baseBuilding ? value.data.baseBuilding : false;
                            props.onChange(value);
                        }}/>
            } ,
            required: true,
            condition: ( request ) => {
                let team = Session.getSelectedTeam(),
                    services = [];
                if ( team ) {
                    if ( team.getAvailableServices ) {
                        services = team.getAvailableServices()
                    }
                }
                if ( _.contains(['Booking','Key Request','Incident', 'Reminder'],request.type) ) {
                    return false;
                } else if ( Teams.isServiceTeam( team ) && !team.services.length <= 1 ) {
                    return false;
                }
                return true;
            },
            options: ( item ) => {
                let selectedTeam = Session.getSelectedTeam(),
                    items = null;

                if ( Teams.isFacilityTeam( selectedTeam ) && item.facility && item.facility._id ) {
                    let facility = Facilities.findOne( item.facility._id );
                    if ( facility ) {
                        items = facility.servicesRequired;
                    }
                } else if ( Teams.isServiceTeam( selectedTeam ) && team.getAvailableServices ) {
                    items = team.getAvailableServices();
                }


                return {
                    items: items,
                    afterChange: ( request ) => {
                        if ( request == null || Teams.isServiceTeam( selectedTeam ) ) {
                            return;
                        }
                        request.supplier = null;
                        request.subservice = null;
                        if (request && request.service && request.service.data ) {
                                let supplier = request.service.data.supplier,
                                    defaultSupplier = null;

                                if ( supplier ) {
                                    if ( supplier._id ) {
                                        defaultSupplier = Teams.findOne( supplier._id );
                                    }
                                    if ( !defaultSupplier && supplier.name ) {
                                        defaultSupplier = Teams.findOne( { name: supplier.name } );
                                    }
                                    request.supplier = defaultSupplier;
                                    if( request.supplier && onServiceChange ) {
                                        onServiceChange( request.supplier );
                                    }
                                    if ( request.service.data.defaultContact && request.service.data.defaultContact.length ) {
                                        request.supplierContacts = request.service.data.defaultContact;
                                    } else if ( Teams.isFacilityTeam( defaultSupplier ) ) {
                                        request.supplierContacts = defaultSupplier.getMembers( { role: 'portfolio manager' } );
                                    } else {
                                        request.supplierContacts = defaultSupplier.getMembers( { role: 'manager' } );
                                    }
                                } else {
                                    request.supplier = null;
                                    request.subservice = null;
                                }
                        }
                    }
                }
            }
        },

        subservice: {
            label: "Subservice",
            description: (item) =>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The subcategory of "+ workRequest +" request";
            },
            size: 6,
            type: "object",
            input: Select,
            condition: ( request ) => {
                let team = Session.getSelectedTeam();
                    services = [];
                if ( team ) {
                    if ( team.getAvailableServices ) {
                        services = team.getAvailableServices()
                    }
                }
                if ( request.type == 'Booking' || request.type == 'Reminder') {
                    return false;
                } else if ( Teams.isServiceTeam( team ) && !team.services.length <= 1 ) {
                    return false;
                }
                return true;
            },
            options: ( request ) => {
                return {
                    items: request.service ? request.service.children : null,
                    afterChange: ( request ) => {
                        if ( request == null ) {
                            return;
                        }
                        if ( request.subservice && request.subservice.data ) {
                            let supplier = request.subservice.data.supplier,
                                defaultSupplier = null;

                            if ( supplier ) {
                                if ( supplier._id ) {
                                    defaultSupplier = Teams.findOne( supplier._id );
                                }
                                if ( !defaultSupplier && supplier.name ) {
                                    defaultSupplier = Teams.findOne( { name: supplier.name } );
                                }
                                request.supplier = defaultSupplier;
                                if ( request.subservice.data.defaultContact && request.subservice.data.defaultContact.length ) {
                                    request.supplierContacts = request.subservice.data.defaultContact;
                                } else if ( Teams.isFacilityTeam( supplier ) ) {
                                    request.supplierContacts = defaultSupplier.getMembers( { role: 'portfolio manager' } );
                                } else {
                                    request.supplierContacts = defaultSupplier.getMembers( { role: 'manager' } );
                                }
                            } else {
                                request.supplier = null;
                            }
                        }
                    }
                }
            }
        },

        //////////////////////////////////////////////////
        // Comments
        //////////////////////////////////////////////////

        description: {
            label: "Comments",
            description: "A detailed description of the work to be completed",
            type: "string",
            input: TextArea,
        },

        issueComment: {
            label: "Comment",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "Comment about the issuing of this"+ workRequest +"request";
            },
            type: "string",
            input: TextArea,
            required: true,
        },

        acceptComment: {
            label: "Comment",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "Comment about the acceptance of this"+ workRequest +"request";
            },
            type: "string",
            input: TextArea,
            required: false,
        },

        rejectComment: {
            label: "Reason for rejection",
            description: "The reason why this job was rejected",
            type: "string",
            input: TextArea,
            required: true,
        },

        closeComment: {
            label: "Close comment",
            description: "Closing comments about this job",
            type: "string",
            input: TextArea,
            required: true,
        },

        reverseComment: {
            label: "Comment",
            description: "Reason for reversal",
            type: "string",
            input: TextArea,
            required: true,
        },

        reopenComment: {
            label: "Provide reason for reopening",
            description: "Reason for reopening",
            type: "string",
            input: TextArea,
            required: true,
        },

        //////////////////////////////////////////////////
        // Quote related
        //////////////////////////////////////////////////

        quoteRequired: {
            label: "Quote required",
            description: "Is a quote required for this job?",
            type: "boolean",
            input: Switch
        },

        quoteIsPreApproved: {
            label: "Auto approve quote?",
            info: "An auto approved quote will ",
            type: "boolean",
            input: Switch
        },

        quote: {
            label: "Quote",
            description: "File detailing the estimated cost of this job",
            input: FileField,
        },

        quoteValue: {
            label: "Value of quote",
            description: "The cost of the requested work",
            type: "number"
        },

        //////////////////////////////////////////////////
        // Settings
        //////////////////////////////////////////////////

        confirmRequired: {
            label: "Completion confirmation required",
            description: "Is manager confirmation required before the job can be closed?",
            input: Switch
        },

        occupancy: {
            label: "Base Building",
            description: "Specify occupancy type",
            size: 12,
            defaultValue: ( item ) => {
                return item.service && item.service.data && item.service.data.baseBuilding;
            },
            condition: ( item ) => {
                let role = Meteor.user().getRole();
                return _.contains(['Ad-hoc', 'Defect'], item.type) && !_.contains(['staff', 'resident'], role) && item.status=='Issued';
            },
            input(props){
                let value = false,
                    team = Session.get( 'selectedTeam' );
                if (!props.value && Teams.isServiceTeam( team ) ) {
                    value = true;
                }
                else if (props.value) {
                    value = props.value;
                }

                return(
                    <div className="row">
                        <div className="col-xs-12">
                            <br/><br/>
                            <Switch
                                value = { value }
                                placeholder = "Base Building"
                                labelInactive = "Tenant"
                                onChange = { ( val ) =>{
                                    props.item.occupancy = val;
                                    props.item.service.data.baseBuilding = val;
                                    props.item.service.data.tenancy = !val;
                                }
                            }
                            />
                        </div>
                    </div>
                    )
            }
        },

        costThreshold: {
            label: "Value",
            type: "number",
            size: 6,
            defaultValue: ( item ) => {
                if(item.type && _.contains(['Key Request','Incident', 'Reminder'],item.type)){
                    return '0';
                }
                // get the default value from the team and return that as default costThreshold
                let team = Session.getSelectedTeam();
                if( team && ( team.defaultWorkOrderValue != null ) ) {
                    return  team.defaultWorkOrderValue;
                }
                // if none exists return 0
                return '0';
            },
            // input: Currency,
            input: (props)=>{
                return <Currency {...props}
                    onChange={(value)=>{
                        // null should equate to 0
                        if( !value ) {
                            value = '0';
                        }
                        props.onChange( value );
                    }}
                />
            },
            condition: ( request ) => {
                if ( _.contains( [ "Defect", "Incident" ], request.type ) ) {
                    return false;
                }
                if(request.type == "Booking"){
                    request.costThreshold = '0';
                    let selectedAreaDetail = null;
                    if(request.identifier && request.identifier.data && request.identifier.data.areaDetails){
                        selectedAreaDetail = request.identifier.data.areaDetails
                    } else if(request.area && request.area.data && request.area.data.areaDetails){
                        selectedAreaDetail = request.area.data.areaDetails
                    } else if(request.level && request.level.data && request.level.data.areaDetails){
                        selectedAreaDetail = request.level.data.areaDetails
                    }

                    if(selectedAreaDetail != null){
                        let unit = selectedAreaDetail.unit,
                            cost = parseInt(_.isEmpty(selectedAreaDetail.cost)?0:selectedAreaDetail.cost),
                            bookingIncreament = 0;
                        if(unit == 'Hours'){
                            bookingIncreament = selectedAreaDetail.hour.replace(/[^\d.-]/g, '');
                        } else if(unit == 'Days'){
                            bookingIncreament = selectedAreaDetail.day.replace(/[^\d.-]/g, '');
                        } else if(unit == 'Months'){
                            bookingIncreament = selectedAreaDetail.month.replace(/[^\d.-]/g, '');
                        } else if(unit == 'Weeks'){
                            bookingIncreament = selectedAreaDetail.week.replace(/[^\d.-]/g, '');
                        }
                        bookingIncreament = parseInt(_.isEmpty(bookingIncreament)?0:bookingIncreament)
                        request.costThreshold = (cost*bookingIncreament*(request.duration == "" ? 0 : parseFloat(request.duration))).toString();

                    }
                } else {
                    // request.costThreshold = '500';
                }
                let role = Meteor.user().getRole();
                if ( role == 'staff' || role == 'tenant' || role == 'resident' ) {
                    return false;
                }
                return true;
            }
        },

        closeDetails: {
            type: "object",
            subschema: CloseDetailsSchema
        },

        //////////////////////////////////////////////////
        // Dates & timing
        //////////////////////////////////////////////////

        dueDate: {
            type: "date",
            label: "Due/Start Date",
            description: "Latest date that the work can be completed",
            input: DateTime,
            size: 6,
            required: true,
            defaultValue: getDefaultDueDate,
            condition: ( request ) => {
                let role = Meteor.user().getRole();
                if ( _.contains( [ 'staff', 'resident', 'tenant' ], role ) && request.type !='Booking' ) {
                    return false;
                }
                if (request.type=='Incident') {
                    return false;
                }
                return true;
            }
        },

        incidenceDate: {
            type: "date",
            label: "When did it happen?",
            description: "The date and time the incident occured",
            input: DateTime,
            size: 6,
            required: true,
            defaultValue: getDefaultDueDate,
            condition: "Incident"
        },

        bookingPeriod: {
            type: "object",
            label: "Booking period",
            description: "Select the booking period",
            input: (props) => {
                return  <CalendarPeriod
                            onChangeValue={(value)=>{
                                props.onChange(value);
                            }}
                            {...props}
                        />
            },

            size: 12,
            required: true,
            defaultValue: {},
            condition: (request)=>{
                if(request.type == "Booking" && request.level && request.level.name){
                    if(request.bookingPeriod && request.bookingPeriod.startTime && request.bookingPeriod.endTime){
                        let duration = moment.duration(moment(request.bookingPeriod.endTime).diff(moment(request.bookingPeriod.startTime)));
                        let hours = duration.asHours();
                        request.duration = hours.toString();
                    } else {
                        request.duration = ''
                    }
                    return true;
                } else {
                    return false;
                }
            }
        },

        issuedAt: {
            type: "date",
            label: "Issued date",
            description: "Date and time that the job was issued",
            input: DateTime,
            size: 6,
            required: true,
            defaultValue: ""
        },

        eta: {
            label: "ETA",
            description: "Time the supplier is expected to attend the site",
            size: 6,
            required: true,
            type: "date",
            input: DateTime,
            defaultValue: ""
        },

        //////////////////////////////////////////////////
        // Relations
        // Should be defined here in the schema and implemented automatically
        //////////////////////////////////////////////////

        team: {
            label: "Client",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The team who created this"+ workRequest +"request";
            },
            type: "object",
            input: Select,
            options: ( item ) => {
                let team = Session.getSelectedTeam();
                return {
                    items: Teams.isServiceTeam( team ) ? team.getClients() : null,
                    view: ContactCard
                }
            },
            defaultValue: ( item ) => {
                let team = Session.getSelectedTeam();
                if ( Teams.isFacilityTeam( team ) ) {
                    return team;
                }
            }
        },

        facility: {
            label: "Site Address",
            description: "The site for this job",
            type: "object",
            required: true,
            defaultValue: ( request ) => {
                let team = Teams.collection._transform( request.team ),
                    facilities = team.getFacilities( { 'team._id': request.team._id } );
                if ( facilities.length == 1 ) {
                    return facilities[ 0 ];
                }
                // return the selected facility.
                return Session.getSelectedFacility();
            },

            input: Select,

            options: ( request ) => {
                let team = Teams.findOne( request.team._id ),
                    role = Meteor.user().getRole(),
                    facilities = team.getFacilities( { 'team._id': request.team._id } );
                /*
                import { Facilities } from '/modules/models/Facilities';
                let facilities = Facilities.findAll( { 'team._id': request.team._id } );
                */
                return {
                    items: facilities,
                    view: FacilityListTile,

                    afterChange: ( request ) => {
                        if ( request == null ) {
                            return;
                        }
                        request.level = null;
                        request.area = null;
                        request.identifier = null;
                        request.service = null;
                        request.subservice = null;
                        request.supplier = null;
                        request.members = ( _.filter( request.members, m => m.role !== defaultContactRole ) );
                    },
                    addNew: {
                        //Add new facility to current selectedTeam.
                        show: !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ), //Meteor.user().getRole() != 'staff',
                        label: "Create New",
                        onAddNewItem: ( callback ) => {
                            import { Facilities, FacilityStepperContainer } from '/modules/models/Facilities';
                            let team = Session.getSelectedTeam(),
                                facility = Facilities.create( { team } );
                            facility = Facilities.collection._transform( facility );
                            Modal.show( {
                                content:
                                    <FacilityStepperContainer params = {
                                        {
                                            item: facility,
                                            onSaveFacility:
                                                ( facility ) => {
                                                    callback( facility );
                                                }
                                        }
                                    }
                                />
                            } )
                        }
                    },
                }
            },
            condition: ( request ) => {
                //do not show this field if number of facilities is one or less
                let team = request.team && request.team._id ? Teams.findOne( request.team._id ) : Session.getSelectedTeam(),
                    facilities = team.getFacilities( { 'team._id': team._id } );
                if ( facilities.length <= 1 ) {
                    return false;
                }
                return true;
            }
        },

        supplier: {
            label: "Supplier",
            description: "The supplier who has been assigned to this job",
            type: "object",
            relation: {
                type: ORM.HasOne,
                source: Teams,
            },
            condition: ( request ) => {

                let team = Session.getSelectedTeam();
                //do not show for booking, contractors, staff or resident
                if( request.type != 'Booking' ) {
                    if( Teams.isFacilityTeam( team ) ) {
                        if( !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ) ) {
                            return true;
                        }
                    }
                }
                return false;

            },
            defaultValue: ( item ) => {
                let team = Session.getSelectedTeam();
                if ( item.type == 'Incident' ) {
                    return team;
                }
                if( Teams.isServiceTeam( team ) ) {
                    return team;
                }
            },
            input:( props ) => {
                return <Select {...props}
                    onChange={( value ) => {
                        let team = Session.getSelectedTeam();
                        let costAbleToIssue = true;
                        if(team.defaultCostThreshold){
                            costAbleToIssue = false;
                            let actualCost = props.item.hasOwnProperty("costThreshold") ? props.item.costThreshold.replace(/,/g, "") : "";
                                actualCost = _.isEmpty(actualCost) ? 0 : parseFloat(actualCost)
                            costAbleToIssue = actualCost <= team.defaultCostThreshold ? true : false;
                        }
                        onServiceChange = costAbleToIssue == true ? props.changeSubmitText(value) : props.changeSubmitText(null)
                        props.onChange(value);
                    }}/>
            } ,
            options: ( item ) => {
                let facility = null,
                    supplier = null,
                    role = Meteor.user().getRole();

                if ( item.facility && item.facility._id ) {
                    facility = Facilities.findOne( item.facility._id );
                    /*if( facility ) {
                        console.log( facility.getSuppliers() );
                    }*/
                }

                return {
                    items: facility && facility.getSuppliers ? facility.getSuppliers() : null,
                    view: ContactCard,
                    readOnly: item.status == 'Issued',
                    addNew: {
                        //Add new supplier to request and selected facility.
                        show: !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ), //Meteor.user().getRole() != 'staff',
                        label: "Create New",
                        onAddNewItem: ( callback ) => {
                            import { TeamStepper } from '/modules/models/Teams';
                            Modal.show( {
                                content: <TeamStepper item = { supplier }
                                facility = { facility }
                                onChange = {
                                    ( supplier ) => {
                                        facility.addSupplier( supplier );
                                        callback( supplier );
                                    }
                                }
                                />
                            } )
                        }
                    },
                    afterChange: ( request, supplier ) => {
                        if( !supplier ) {
                            request.supplierContacts = [];
                        }
                        else if ( Teams.isFacilityTeam( supplier ) ) {
                            request.supplierContacts = supplier.getMembers( { role: 'portfolio manager' } );
                        } else {
                            request.supplierContacts = supplier.getMembers( { role: 'manager' } );
                        }
                    }
                }
            },
        },

        supplierContacts: {
            label: "Supplier contacts",
            type: 'array',
            size: 12
        },

        supplierContact: {
            label: 'Supplier contact',
            type: 'string',
            size: 12,
            condition: ( request ) => {
                let selectedTeam = Session.get( 'selectedTeam' );
                //do not show for booking, contractors, staff or resident
                return (
                    (
                        request.status != 'Issued' &&
                        request.type != 'Booking' &&
                        //Teams.isServiceTeam( selectedTeam )
                        Teams.isFacilityTeam( selectedTeam )
                    ) ?
                    ( !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ) ) : false
                )
            },
            input( props ) {
                if ( !props.item.supplierContacts ) {
                    props.item.supplierContacts = [];
                }
                // this should be in it's own component
                return (
                        <div className="row">
                    <div className="col-xs-12">
                        <Select
                            placeholder     = "Supplier contact"
                            items           = {props.items}
                            Model           = {props.Model}
                            view            = {props.view}
                            item            = {props.item}
                            onChange        = { ( val ) => {
                                let memberExists = props.item.supplierContacts.find( ( contact ) => {
                                    return contact._id === val._id;
                                } );
                                if ( !memberExists) {
                                    props.item.supplierContacts.push( {
                                        _id: val._id,
                                        name: val.name || val.profile.name,
                                        role: defaultContactRole,
                                        email: val.profile.email,
                                    } );
                                    props.onChange( "" );
                                }
                            } }
                        />
                    </div>
                    <div className="col-xs-12">
                        {_.map( props.item.supplierContacts, ( sc, i ) => (
                            <div className="col-sm-5" key={i}
                                style={{
                                    backgroundColor: 'aliceblue',
                                    padding: '5px',
                                    border: '1px solid transparent',
                                    borderRadius: '5px',
                                    margin: '5px',
                                    borderLeft: '4px solid aquamarine',
                                }}>
                                <span onClick={() => {
                                        let id = sc._id,
                                            newValue =  _.filter( props.item.supplierContacts,  v => v._id !== id );
                                        props.item.supplierContacts = newValue;
                                        props.onChange( "" );
                                    }}
                                    style={{
                                        float: 'right',
                                        cursor: 'pointer',
                                        fontSize: '14px',
                                        fontWeight: 'bold',
                                        marginRight: '0px',
                                        marginTop: '-6px',
                                    }} title="Remove tag">&times;</span>
                                <ContactCard item={sc} team={props.team} group={props.group} />
                            </div>))}
                    </div> </div>)
                    },
                    options( item ) {
                        let supplier = null,
                            members = [];
                        if ( item.supplier ) {
                            let query = {};
                            item.supplier._id ? ( query._id = item.supplier._id ) : ( query.name = item.supplier.name );
                            supplier = Teams.findOne( query );
                        }
                        if ( supplier && supplier.members ) {
                            ids = _.pluck( supplier.members, '_id' );
                            members = Users.findAll( { _id: { $in: ids } } );
                        }
                        return {
                            readOnly: item.status == 'Issued',
                            items: members,
                            view: ContactCard
                        }
                    }
            },

            assignee: {
                label: "Assignee",
                description: "The individual who has been allocated to this job",
                condition: ( request ) => {
                    /*if ( request.supplier && request.supplier._id ) {
                        let team = Session.getSelectedTeam();
                        if( team._id == request.supplier._id ) {
                            let userRole = Meteor.user().getRole();
                            if( _.contains( [ 'portfolio manager', 'manager' ], userRole ) ) {
                                return true;
                            }
                        }
                    }
                    return false;*/
                    let role = Meteor.user().getRole();
                    if (role == 'caretaker' || role == 'staff' || role == 'resident' || role == 'tenant' ) {
                        return false;
                    }
                    let team = Session.getSelectedTeam();
                    if ( request.supplier && ( team._id == request.supplier._id || team.name == request.supplier.name ) ) {
                        return true;
                    }
                    if(_.contains( [ "portfolio manager", 'manager'], role )){
                        return true;
                    }
                    return false;
                },
                input: Select,
                type: "object",
                options: ( request ) => {
                    request = Requests.collection._transform( request );

                    let members = null,
                        supplier = null;

                    if( request.supplier && request.supplier._id ) {
                        let supplier = Teams.findOne( request.supplier._id );
                        if( supplier ) {
                            members = supplier.getMembers();
                        }
                    }

                    return {
                        items: members,
                        view: ContactCard,
                        addNew: {
                            //Add new facility to current selectedTeam.
                            show: Meteor.user().getRole() != 'staff',
                            label: "Add New",
                            onAddNewItem: ( callback ) => {
                                import { Users, UserViewEdit } from '/modules/models/Users';
                                if( supplier ) {
                                    Modal.show( {
                                        content: <UserViewEdit group={ supplier } team={ supplier } addPersonnel={ ( newAssignee ) => callback( newAssignee ) }/>
                                    } )
                                }
                            }
                        },
                        afterChange: ( item ) => {
                            if( !item.members ) {
                                item.members = [];
                            }
                            let found = false;
                            if ( item.assignee && item.assignee._id ) {

                                import { Users } from '/modules/models/Users';

                                let assignee = Users.findOne( item.assignee._id );

                                for ( i in item.members ) {
                                    let member = item.members[ i ];
                                    if ( member.role == "assignee" ) {
                                        item.members[ i ] = {
                                            _id: assignee._id,
                                            name: assignee.profile.name,
                                            role: "assignee"
                                        };
                                        found = true;
                                        break;
                                    }
                                }
                                if ( !found ) {
                                    item.members.push( {
                                        _id: assignee._id,
                                        name: assignee.profile.name,
                                        role: "assignee"
                                    } );
                                }
                            }
                        }
                    }
                },
            },

            members: {
                label: "Contacts",
                description: (item)=>{
                    let workRequest = "work";
                    if(!_.isEmpty(item.type)){
                        workRequest = item.type
                    }
                    return "Stakeholders for this"+ workRequest +"request";
                },
            },

            documents: {
                label: "Documents",
                description: "Saved request documents",
                type: "array",
                /*relation:
                {
                    type: ORM.HasMembers,
                    source: "Files",
                    key: "team._id"
                },*/
                input: DocExplorer
            },

            attachments: {
                label: "Attachments",
                type: "array",
                input: FileExplorer
            },

            //////////////////////////////////////////////////
            //}

            requireServiceReport: {
                label: "Require Service Report",
                type: "boolean",
                defaultValue: false,
                input: Switch,
                condition: () => {
                    let role = Meteor.user().getRole();
                    return _.indexOf( [ "manager", "portfolio manager", "team portfolio manager", "team manager" ], role ) > -1;
                }
            },

            requireInvoice: {
                label: "Require Invoice",
                type: "boolean",
                defaultValue: false,
                input: Switch,
                condition: () => {
                    let role = Meteor.user().getRole();
                    return _.indexOf( [ "manager", "portfolio manager", "team portfolio manager", "team manager" ], role ) > -1;
                }
            },

            footer: {
                size: 12,
                input( props ) {
                    let period
                    if ( props.item.frequency.period ) {
                        switch ( props.item.frequency.period ) {
                            case "daily":
                                period = "day"
                                break;
                            case "fortnightly":
                                period = "fortnight"
                                break;
                            case "weekly":
                                period = "week"
                                break;
                            case "monthly":
                                period = "month"
                                break;
                            case "quarterly":
                                period = "quarter"
                                break;
                            case "annually":
                                period = "year"
                                break;
                            default:

                        }
                        period = period || props.item.frequency.period;
                        period = formatSingularPlural(period);
                    }
                    return (
                        <div style={{paddingTop: "10%", fontWeight:"500",fontSize:"16px"}}>
                            {props.item.frequency.number && props.item.frequency.period && props.item.frequency.endDate?
                                <div>
                                    {`Repeats every ${props.item.frequency.number} ${period} until ${moment(props.item.frequency.endDate).format("D MMMM YYYY")}`}
                                </div>:(
                                    props.item.frequency.number && props.item.frequency.period ?
                                    <div>
                                        {`Repeats every ${props.item.frequency.number} ${period} until stopped`}
                                    </div>:(
                                        props.item.frequency.period && props.item.frequency.endDate?
                                        <div>
                                            {props.item.frequency.endDate?`Repeats ${formatSingularPlural(props.item.frequency.period)} until ${moment(props.item.frequency.endDate).format("D MMMM YYYY")}`:null}
                                        </div>:
                                        <div>
                                            {props.item.frequency.unit?`Repeats ${props.item.frequency.period?formatSingularPlural(props.item.frequency.period):null || formatSingularPlural(props.item.frequency.unit)} until stopped`:null}
                                        </div>
                                    )
                                )
                            }
                        </div>
                    );
                },
                condition: "Preventative",
            }

        }


        function getTimeframe( _id, priority ) {
            //let team = this.getTeam();
            let team = Teams.findOne( { _id: _id } );
            if ( team ) {
                return team.getTimeframe( priority );
            }
        }

        function getJobCode( item ) {
            let team = null,
                code = 0;

            if ( item && item.team ) {
                team = Teams.findOne( {
                    _id: item.team._id
                } );
                code = team.getNextWOCode();
            }

            return code;
        }

        function getDefaultDueDate( item ) {
            if ( !item.team ) {
                return new Date();
            }
            let team = Teams.findOne( item.team._id ),
                timeframe = team.timeframes[ 'Standard' ] * 1000,
                now = new Date();

            return new Date( now.getTime() + timeframe );
        }

        function getRole() {
            return RBAC.getRole( Meteor.user(), Session.getSelectedTeam() );
        }

        function formatSingularPlural(str) {
            if (str.slice(-1)=='s') {
                str =  str.substring(0, str.length-1)+"(s)";
            }
            return str;
        }

        export default RequestSchema;
