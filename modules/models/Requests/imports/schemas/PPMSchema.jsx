/**
 * @author          Leo Keith <leo@fmclarity.com>
 * @copyright       2016 FM Clarity Pty Ltd.
 */

import CloseDetailsSchema from './CloseDetailsSchema.jsx';
import InvoiceDetailsSchema from './InvoiceDetailsSchema.jsx';
import RequestLocationSchema from './RequestLocationSchema.jsx';
import RequestFrequencySchema from './RequestFrequencySchema.jsx';
import IncidentCommentSchema from './IncidentCommentSchema.jsx';

import { Teams } from '/modules/models/Teams';
import { Users } from '/modules/models/Users';
import { Requests } from '/modules/models/Requests';
import { DocExplorer } from '/modules/models/Documents';
import { FileExplorer,Files } from '/modules/models/Files';
import { Facilities, FacilityListTile } from '/modules/models/Facilities';

import { ContactCard } from '/modules/mixins/Members';
import { Text, TextArea, Select, CalendarPeriod, DateTime, Switch, DateInput, FileField, Currency } from '/modules/ui/MaterialInputs';
import AddressSchema from './AddressSchema.jsx'

import React from "react";
import moment from 'moment';
/**
 * @memberOf        module:models/Requests
 */
const defaultContactRole = 'supplier manager';
let onServiceChange = null;

const PPMSchema = {

        //$schema:              "http://json-schema.org/draft-04/schema#",
        //title:                "Request",
        //description:          "A work request",

        //properties:
        //{
        _id: {
            label: "Auto generated document id",
            description: "Document id generated by Mongo",
            type: "string",
            input: Text,
            options: {
                readonly: true
            },
            defaultValue: () => {
                return Random.id();
            }
        },

        name: {
            label: "Summary",
            type: "string",
            required: true,
            maxLength: 90,
            input: Text,
            condition: (item)=>{
                return item.type != 'Booking';
            },
            description: (item)=>{
                let workRequest = "work request";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type + " details"
                }
                return "A brief, descriptive, title for the " + workRequest;
            }
        },

        code: {
            label: "Code",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The unique code for this"+ workRequest +"request";
            },
            type: "number",
            input: Text,
            defaultValue: getJobCode,
            options: {
                readonly: true
            }
        },

    
        priority: {
            label: "Priority",
            description: (item) =>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The urgency of the "+ workRequest +" request";
            },
            type: "string",
            defaultValue: (item) =>{
                let priority = "Standard";
                if(item.type == 'Incident'){
                    priority = 'Urgent'
                }
                return priority;
            },
            required: true,
            condition: ( request ) => {
                if ( request.type == "Schedular" || request.type == 'Booking' ) {
                    return false;
                }
                return true;
            },
            input: Select,
            size: 6,
            options: ( item ) => {
                return ( {
                    items: [
                        "Standard",
                        "Scheduled",
                        "Urgent",
                        "Critical"
                    ],
                    afterChange: ( item ) => {
                        let timeframe, dueDate;
                        if ( item.team && item.priority ) {
                            timeframe = getTimeframe( item.team._id, item.priority );
                            timeframe *= 1000;
                            dueDate = ( ( ( new Date() ).getTime() ) + timeframe );
                            item.dueDate = new Date( dueDate );
                        }
                    }
                } )
            }
        },

        frequency: {
            label: "Frequency",
            description: "The unit (days, weeks, months etc) of the repeats",
            input( props ) {
                return (
                    <Select
    	      			placeholder = { props.placeholder }
    	      			item = { props.item }
    	      			items = { props.items }
                        errors = { props.errors }
    	      			value = { props.value.unit }
    	      			onChange = { (item) => {
                            props.onChange(item)
                        }}
    	    		/>
                );
            },
            condition: (request)=>{
                if(request.type == "Schedular"){
                    return true;
                }else{
                    return false
                }
            },
            //subschema: RequestFrequencySchema,
            required: true,
            type: "object",
            //type: "string",
            //nextRow: true,
            size: 6,
            options: {
                items: [
                    { name: 'Daily', val: "days" },
                    { name: 'Weekly', val: "weeks" },
                    { name: 'Fortnightly', val: "fortnights" },
                    { name: 'Monthly', val: "months" },
                    { name: 'Quarterly', val: "quarters" },
                    { name: 'Annually', val: "years" },
                    { name: 'Custom', val: "custom" },
                ],
                afterChange( item ) {
                    frequency = item.frequency;
                    item.frequency = !_.isEmpty(frequency)?{
                        number: 1,
                        repeats: 10,
                        period: "",
                        endDate: "",
                        unit: frequency
                    }:{};
                }
            },
        },

        number: {
            label: "Repeats every...",
            description: "The number of days, weeks, months etc.",
            input: (props) =>{
                return <Text
                    placeholder = { props.placeholder }
                    description = { props.description }
                    errors = { props.errors }
                    fieldName = { props.fieldName }
                    item = { props.item }
                    items = { props.items }
                    value = { props.item.frequency.number }
                    onChange = { (item) => {
                        props.onChange(item)
                    }}
                />
            },
            type: "number",
            size: 6,
            options: {
                afterChange( item ) {
                    item.frequency.number = item.number;
                    item = _.omit(item,"number");
                    //number = item.number;
                }
            },
            //condition: item => item.unit === "custom",
            condition: (request)=>{
                if(request.frequency && request.frequency.unit == "custom"){
                    return true;
                }
                return false;
            }
        },

        period: {
            label: "Period",
            description: "The unit (days, weeks, months etc) of the repeats",
            input( props ) {
                props.item.frequency.period = props.item.frequency.period ? props.item.frequency.period : ( props.item.frequency.unit === "custom" ? "months" : "" );
                return (
                    <Select
    					placeholder = { props.placeholder }
    		        	item = { props.item }
    		        	items = { props.items }
    		        	value = { props.item.frequency.period ? props.item.frequency.period : "months" }
    		        	onChange = { item => props.onChange(item) } />
                )
            },
            defaultValue: "months",
            type: "string",
            size: 6,
            options: {
                items: [
                    { name: 'Day', val: "days" },
                    { name: 'Week', val: "weeks" },
                    { name: 'Fortnight', val: "fortnights" },
                    { name: 'Month', val: "months" },
                    { name: 'Quarter', val: "quarters" },
                    { name: 'Year', val: "years" },
                ],
                //afterChange: item => { period = item.period; },
                afterChange( item ) {
                    item.frequency.period = item.period;
                    item = _.omit(item,"period");
                    //number = item.number;
                }
            },
            //condition: item => item.unit === "custom",
            condition: (request)=>{
                if(request.frequency && request.frequency.unit == "custom"){
                    return true;
                }
                return false;
            }
        },

        endDate: {
            label: 'End date',
            size: 6,
            //input: DateInput,
            input: (props)=>{
                return <DateInput
                    placeholder = { props.placeholder }
                    errors = { props.errors }
                    item = { props.item }
                    items = { props.items }
                    value = { props.item.frequency.endDate }
                    onChange = { (item) => {
                        props.onChange(item)
                    }}
                />
            },
            options: {
                afterChange( item ) {
                    item.frequency.endDate = item.endDate;
                    item = _.omit(item,"endDate");
                    //number = item.number;
                }
            },
            //condition: item => item.unit === "custom",
            condition: (request)=>{
                if(request.frequency && request.frequency.unit == "custom"){
                    return true;
                }
                return false;
            }
        },

        duration: {
            label: "Duration",
            type: "string",
            input: Text,
            size: 6,
            required: true,
            condition: "Booking"
        },

        status: {

            label: "Status",
            description: "The current status of the job",
            type: "string",
            input: Select,
            readonly: true,
            defaultValue: "Draft",
            /*() => {
                        let role = Meteor.apply( 'User.getRole', [], { returnStubValue: true } );
                        return _.indexOf( [ "portfolio manager", "manager" ], role ) > -1 ? "New" : "Draft";
                    },*/

            options: {
                items: [
                    'Draft',
                    'New',
                    'Approved',
                    'Accepted',
                    'Quoting',
                    'Complete',
                    'Closed'
                ]
            }
        },

        //////////////////////////////////////////////////
        // Facility dependant properties
        //////////////////////////////////////////////////
        incidentVictim: {
            label: "Who did it happen to & what's their contact details?",
            type: "string",
            input: Text,
            size: 12,
            required: true,
            condition: "Incident"
        },
        location: {
            label: "Where did it happen?",
            type: "string",
            input: TextArea,
            size: 6,
            required: true,
            condition: "Incident"
        },
        reporter: {
             label: "Reporter",
             description: "Who reported the incident",
             type: "object",
             input: Select,
             required: true,
             options: ( request ) => {
                     request = Requests.collection._transform( request );
                     let team = request.getFacility() || request.getTeam(),
                         members = team.getMembers();
                     return {
                         items: members,
                         view: ContactCard
                     }
             },
             condition: "Incident"
         },
        reporterContact: {
            label: "Reporter Contact details",
            type: "string",
            input: TextArea,
            size: 6,
            required: true,
            condition: "Incident"
        },
        incidentFurtherComments: {
            type: "object",
            subschema: IncidentCommentSchema,
            condition: "Incident"
        },
        level: {
            label: "Location - Area",
            size: 4,
            type: "object",
            input:( props ) => {
                return <Select {...props}
                        onChange={( value ) => {
                            props.item.area = {};
                            props.onChange(value);
                        }}/>
            } ,
            required: true,
            condition: ( item ) => {
                let selectedTeam = Session.get( 'selectedTeam' );
                if (item.type=="Incident") {
                    return false;
                }
                return Teams.isFacilityTeam( selectedTeam ) || !_.isEmpty( item.level );
            },
            options: ( item ) => {
                let facility = null;
                if ( item.facility ) {
                    facility = Facilities.findOne( item.facility._id );
                }
                let areas = []
                if(item.type == "Booking"){
                    let allArea = facility ? facility.areas : []
                    allArea.map( ( area, idx ) => {
                        if(area.data && area.data.areaDetails && area.data.areaDetails.type == "Bookable"){
                            if(_.find(areas, function(obj){ return obj.name == area.name; }) == undefined){
                                areas.push(area)
                            }
                        } else if(area.children && area.children.length > 0){
                            area.children.map(( area2, idx2) => {
                                if(area2.data && area2.data.areaDetails  && area2.data.areaDetails.type == "Bookable"){
                                    if(_.find(areas, function(obj){ return obj.name == area.name; }) == undefined){
                                        areas.push(area)
                                    }
                                } else if(area2.children && area2.children.length > 0){
                                    area2.children.map(( area3, idx3) => {
                                        if(area3.data && area3.data.areaDetails  && area3.data.areaDetails.type == "Bookable"){
                                            if(_.find(areas, function(obj){ return obj.name == area.name; }) == undefined){
                                                areas.push(area)
                                            }
                                        }
                                    })
                                }
                            })
                        }
                    })
                } else {
                    areas = facility ? facility.areas : null
                }
                return {
                    items: areas,
                    readOnly: item.type == 'Key Request',
                }
            },
            defaultValue: (request ) => {
                let user = Meteor.user(), val=null;
                if (request.type=="Incident") {
                    return val;
                }
                if ( user.profile.tenancy && user.profile.tenancy.level && _.contains( [ 'tenant' ], user.getRole() ) ) {
                    val = user.profile.tenancy.level;
                }
                if (user.getRole() == 'resident' && request.type == 'Key Request' ) {
                    val = user.apartment ? user.apartment : null;
                }
                return val;
            },
        },

        bookingRules:{
            label: "Booking rules/instructions",
            size: 4,
            type: "string",
            input: (props) =>{
                return <div style={{marginTop:"20px"}}><a
                    title = {"Read"}
                    onClick={()=>{
                        let item = props.item;
                        let file,isImage,extension;
                        if(item.level && item.level.data && item.level.data.areaDetails && item.level.data.areaDetails.attachments && item.level.data.areaDetails.attachments.length){
                            file = item.level.data.areaDetails.attachments[0]
                        }
                        if( item.area && item.area.data && item.area.data.areaDetails && item.area.data.areaDetails.attachments && item.area.data.areaDetails.attachments.length){
                            file = item.area.data.areaDetails.attachments[0]
                        }
                        if( item.identifier && item.identifier.data && item.identifier.data.areaDetails && item.identifier.data.areaDetails.attachments && item.identifier.data.areaDetails.attachments.length){
                            file = item.identifier.data.areaDetails.attachments[0]
                        }
                        if(!_.isEmpty(file)){
                            file = Files.findOne( file._id );
                            extension = file.extension();
                            isImage = file.isImage() && extension != 'tif';
                        }
                        if ( isImage ) {
                            Modal.show( {
                    			content: <img style={{width:"100%","borderRadius":"1px",marginTop:"10px"}} alt="image" src={file.url()} />
                    		} )
            			} else if ( file ) {
                            let win = window.open( file.url(), '_blank' );
                    		win.focus();
            			}
                    }}>Booking rules/instructions</a>
                </div>
            },
            condition: (item)=>{
                let toReturn = false;
                if(item.type == "Booking"){
                    if(item.level && item.level.data && item.level.data.areaDetails){
                        toReturn = false;
                        if(item.level.data.areaDetails.attachments && item.level.data.areaDetails.attachments.length){
                            toReturn = true;
                        }
                    }
                    if(item.area && item.area.data && item.area.data.areaDetails){
                        toReturn = false;
                        if( item.area.data.areaDetails.attachments && item.area.data.areaDetails.attachments.length){
                            toReturn = true;
                        }
                    }
                    if(item.identifier && item.identifier.data && item.identifier.data.areaDetails){
                        toReturn = false;
                        if( item.identifier.data.areaDetails.attachments && item.identifier.data.areaDetails.attachments.length){
                            toReturn = true;
                        }
                    }
                    return toReturn;
                }
            }
        },

        area: {
            label: "Sub-area",
            size: 4,
            type: "object",
            required: false,
            input:( props ) => {
                return <Select {...props}
                        onChange={( value ) => {
                            props.item.identifier = {};
                            props.onChange(value);
                        }}/>
            } ,
            condition: ( item ) => {
                if(
                    item.type == "Booking"
                    && item.level
                    && item.level.data
                    && item.level.data.areaDetails
                    && item.level.data.areaDetails.type != "Bookable"
                )
                {
                    PPMSchema.area.required = true;
                } else {
                    PPMSchema.area.required = false;
                }
                let selectedTeam = Session.get( 'selectedTeam' ),
                    teamType = null;
                if ( selectedTeam ) {
                    teamType = selectedTeam.type;
                }
                return teamType == 'fm' || !_.isEmpty( item.area );
            },
            options: ( item ) => {
                let subAreas = [];
                if(item.type == "Booking"){
                    let allSubArea = item.level && item.level.children ? item.level.children : []
                    allSubArea.map( ( area, idx ) => {
                        if(area.data && area.data.areaDetails && area.data.areaDetails.type == "Bookable"){
                            if(_.find(subAreas, function(obj){ return obj.name == area.name; }) == undefined){
                                subAreas.push(area)
                            }
                        } else if(area.children && area.children.length > 0){
                            area.children.map(( area2, idx2) => {
                                if(area2.data && area2.data.areaDetails  && area2.data.areaDetails.type == "Bookable"){
                                    if(_.find(subAreas, function(obj){ return obj.name == area.name; }) == undefined){
                                        subAreas.push(area)
                                    }
                                }
                            })
                        }
                    } )
                } else {
                    subAreas = item.level ? item.level.children : null
                }
                return {
                    items: subAreas
                }
            }
        },

        identifier: {
            label: "Identifier",
            description: "Area identifier for the job location (ie classroom number)",
            size: 4,
            type: "object",
            input: Select,
            required:false,
            condition: ( item ) => {
                if(
                    item.type == "Booking"
                    && item.area
                    && item.area.data
                    && item.area.data.areaDetails
                    && item.area.data.areaDetails.type != "Bookable"
                )
                {
                    PPMSchema.identifier.required = true;
                } else {
                    PPMSchema.area.required = false;
                }
                let selectedTeam = Session.get( 'selectedTeam' ),
                    teamType = null;
                if ( selectedTeam ) {
                    teamType = selectedTeam.type;
                }
                return teamType == 'fm' || !_.isEmpty( item.identifier );
            },
            options: ( item ) => {
                let subAreas =[];
                if(item.type == 'Booking'){
                    let allSubArea = item.area && item.area.children ? item.area.children : []
                    allSubArea.map( ( area, idx ) => {
                        if(area.data && area.data.areaDetails && area.data.areaDetails.type == "Bookable"){
                            subAreas.push(area)
                        }
                    })
                } else {
                    subAreas = item.area ? item.area.children : null
                }
                return {
                    items: subAreas
                }
            }
        },

        //////////////////////////////////////////////////

        service: {
            label: "Service",
            description: (item) =>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The category of "+ workRequest +" request";
            },
            size: 6,
            type: "object",
            defaultValue: ( item ) => {
                if (item.type == "Key Request") {
                    var services = Session.getSelectedFacility() && Session.getSelectedFacility().servicesRequired;
                    if (services) {
                        for (var i = 0; i < services.length; i++) {
                            var name = services[i].name;
                            if (name.indexOf('keys') !== -1) {
                                item.service = services[i];
                                break;
                            }
                        }
                    }
                }
            },
            input:( props ) => {
                return <Select {...props}
                        onChange={( value ) => {
                            let team = Session.getSelectedTeam();
                            let costAbleToIssue = true;
                            if(team.defaultCostThreshold){
                                costAbleToIssue = false;
                                let actualCost = props.item.hasOwnProperty("costThreshold") ? props.item.costThreshold.replace(/,/g, "") : "";
                                    actualCost = _.isEmpty(actualCost) ? 0 : parseFloat(actualCost)
                                costAbleToIssue = actualCost <= team.defaultCostThreshold ? true : false;
                            }
                            onServiceChange = costAbleToIssue == true ? props.changeSubmitText : props.changeSubmitText(null)
                            props.item.occupancy = value && value.data && value.data.baseBuilding ? value.data.baseBuilding : false;
                            props.onChange(value);
                        }}/>
            } ,
            required: true,
            condition: ( request ) => {
                let team = Session.getSelectedTeam(),
                    services = [];
                if ( team ) {
                    if ( team.getAvailableServices ) {
                        services = team.getAvailableServices()
                    }
                }
                if ( _.contains(['Booking','Key Request','Incident', 'Reminder'],request.type) ) {
                    if (request.type=='Key Request' && Meteor.user().getRole()=='manager') {
                        return true;
                    }
                    return false;
                } else if ( Teams.isServiceTeam( team ) && !team.services.length <= 1 ) {
                    return false;
                }
                return true;
            },
            options: ( item ) => {
                let selectedTeam = Session.getSelectedTeam(),
                    items = null;

                if ( Teams.isFacilityTeam( selectedTeam ) && item.facility && item.facility._id ) {
                    let facility = Facilities.findOne( item.facility._id );
                    if ( facility ) {
                        items = facility.servicesRequired;
                    }
                } else if ( Teams.isServiceTeam( selectedTeam ) && team.getAvailableServices ) {
                    items = team.getAvailableServices();
                }


                return {
                    items: items,
                    afterChange: ( request ) => {
                        if ( request == null || Teams.isServiceTeam( selectedTeam ) ) {
                            return;
                        }
                        request.supplier = null;
                        request.subservice = null;
                        if (request && request.service && request.service.data ) {
                                let supplier = request.service.data.supplier,
                                    defaultSupplier = null;

                                if ( supplier ) {
                                    if ( supplier._id ) {
                                        defaultSupplier = Teams.findOne( supplier._id );
                                    }
                                    if ( !defaultSupplier && supplier.name ) {
                                        defaultSupplier = Teams.findOne( { name: supplier.name } );
                                    }
                                    request.supplier = defaultSupplier;
                                    if( request.supplier && onServiceChange ) {
                                        onServiceChange( request.supplier );
                                    }
                                    if ( request.service.data.defaultContact && request.service.data.defaultContact.length ) {
                                        request.supplierContacts = request.service.data.defaultContact;
                                    } else if ( Teams.isFacilityTeam( defaultSupplier ) ) {
                                        request.supplierContacts = defaultSupplier.getMembers( { role: 'portfolio manager' } );
                                    } else {
                                        request.supplierContacts = defaultSupplier.getMembers( { role: 'manager' } );
                                    }
                                } else {
                                    request.supplier = null;
                                    request.subservice = null;
                                }
                        }
                    }
                }
            }
        },

        subservice: {
            label: "Subservice",
            description: (item) =>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The subcategory of "+ workRequest +" request";
            },
            size: 6,
            type: "object",
            input: Select,
            condition: ( request ) => {
                let team = Session.getSelectedTeam();
                    services = [];
                if ( team ) {
                    if ( team.getAvailableServices ) {
                        services = team.getAvailableServices()
                    }
                }
                if ( request.type == 'Booking' || request.type == 'Reminder') {
                    return false;
                } else if ( Teams.isServiceTeam( team ) && !team.services.length <= 1 ) {
                    return false;
                }
                return true;
            },
            options: ( request ) => {
                return {
                    items: request.service ? request.service.children : null,
                    afterChange: ( request ) => {
                        if ( request == null ) {
                            return;
                        }
                        if ( request.subservice && request.subservice.data ) {
                            let supplier = request.subservice.data.supplier,
                                defaultSupplier = null;

                            if ( supplier ) {
                                if ( supplier._id ) {
                                    defaultSupplier = Teams.findOne( supplier._id );
                                }
                                if ( !defaultSupplier && supplier.name ) {
                                    defaultSupplier = Teams.findOne( { name: supplier.name } );
                                }
                                request.supplier = defaultSupplier;
                                if ( request.subservice.data.defaultContact && request.subservice.data.defaultContact.length ) {
                                    request.supplierContacts = request.subservice.data.defaultContact;
                                } else if ( Teams.isFacilityTeam( supplier ) ) {
                                    request.supplierContacts = defaultSupplier.getMembers( { role: 'portfolio manager' } );
                                } else {
                                    request.supplierContacts = defaultSupplier.getMembers( { role: 'manager' } );
                                }
                            } else {
                                request.supplier = null;
                            }
                        }
                    }
                }
            }
        },

        //////////////////////////////////////////////////
        // Comments
        //////////////////////////////////////////////////

        description: {
            label: "Comments",
            description: "A detailed description of the work to be completed",
            type: "string",
            input: TextArea,
        },

        issueComment: {
            label: "Comment",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "Comment about the issuing of this"+ workRequest +"request";
            },
            type: "string",
            input: TextArea,
            required: true,
        },

        acceptComment: {
            label: "Comment",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "Comment about the acceptance of this"+ workRequest +"request";
            },
            type: "string",
            input: TextArea,
            required: false,
        },

        rejectComment: {
            label: "Reason for rejection",
            description: "The reason why this job was rejected",
            type: "string",
            input: TextArea,
            required: true,
        },

        closeComment: {
            label: "Close comment",
            description: "Closing comments about this job",
            type: "string",
            input: TextArea,
            required: true,
        },

        reverseComment: {
            label: "Comment",
            description: "Reason for reversal",
            type: "string",
            input: TextArea,
            required: true,
        },

        reopenComment: {
            label: "Provide reason for reopening",
            description: "Reason for reopening",
            type: "string",
            input: TextArea,
            required: true,
        },

        //////////////////////////////////////////////////
        // Quote related
        //////////////////////////////////////////////////

        quoteRequired: {
            label: "Quote required",
            description: "Is a quote required for this job?",
            type: "boolean",
            input: Switch
        },

        quoteIsPreApproved: {
            label: "Auto approve quote?",
            info: "An auto approved quote will ",
            type: "boolean",
            input: Switch
        },

        quote: {
            label: "Quote",
            description: "File detailing the estimated cost of this job",
            input: FileField,
        },

        quoteValue: {
            label: "Value of quote",
            description: "The cost of the requested work",
            type: "number"
        },

        //////////////////////////////////////////////////
        // Settings
        //////////////////////////////////////////////////

        confirmRequired: {
            label: "Completion confirmation required",
            description: "Is manager confirmation required before the job can be closed?",
            input: Switch
        },

        occupancy: {
            label: "Base Building",
            description: "Specify occupancy type",
            size: 12,
            defaultValue: ( item ) => {
                return item.service && item.service.data && item.service.data.baseBuilding;
            },
            condition: ( item ) => {
                let role = Meteor.user().getRole();
                return _.contains(['Ad-hoc', 'Defect'], item.type) && !_.contains(['staff', 'resident'], role) && item.status=='Issued';
            },
            input(props){
                let value = false,
                    team = Session.get( 'selectedTeam' );
                if (!props.value && Teams.isServiceTeam( team ) ) {
                    value = true;
                }
                else if (props.value) {
                    value = props.value;
                }

                return(
                    <div className="row">
                        <div className="col-xs-12">
                            <br/><br/>
                            <Switch
                                value = { value }
                                placeholder = "Base Building"
                                labelInactive = "Tenant"
                                onChange = { ( val ) =>{
                                    props.item.occupancy = val;
                                    props.item.service.data.baseBuilding = val;
                                    props.item.service.data.tenancy = !val;
                                }
                            }
                            />
                        </div>
                    </div>
                    )
            }
        },

        costThreshold: {
            label: "Value",
            type: "number",
            size: 6,
            defaultValue: ( item ) => {
                if(item.type && _.contains(['Key Request','Incident'],item.type)){
                    return '0';
                }
                // get the default value from the team and return that as default costThreshold
                let team = Session.getSelectedTeam();
                if( team && ( team.defaultWorkOrderValue != null ) ) {
                    return  team.defaultWorkOrderValue;
                }
                // if none exists return 0
                return '0';
            },
            // input: Currency,
            input: (props)=>{
                return <Currency {...props}
                    onChange={(value)=>{
                        // null should equate to 0
                        if( !value ) {
                            value = '0';
                        }
                        props.onChange( value );
                    }}
                    readOnly = {(props.edit && props.edit == true) && (props.item && props.item.status == "Booking") ? true : false}
                />
            },
            condition: ( request ) => {
                if ( _.contains( [ "Defect", "Incident" ], request.type ) ) {
                    return false;
                }
                if(request.type == "Booking"){
                    request.costThreshold = '0';
                    let selectedAreaDetail = null;


                    /*if(request.level && request.level.data && request.level.data.areaDetails){
                        selectedAreaDetail = request.level.data.areaDetails
                    }
                    if(request.area && request.area.data && request.area.data.areaDetails){
                        selectedAreaDetail = request.area.data.areaDetails
                    }
                    if(request.identifier && request.identifier.data && request.identifier.data.areaDetails){
                        selectedAreaDetail = request.identifier.data.areaDetails
                    }*/


                    let facility = Facilities.findOne( request.facility._id )
                    let parentArea = null,
                        childArea = null;
                    if(request.level && request.level.name){
                        _.map( facility.areas, ( ar, i ) => {
                            if(ar.name == request.level.name){
                                parentArea = ar;
                                selectedAreaDetail = ar.data && ar.data.areaDetails;
                            }
                        })
                    }
                    if(request.area && request.area.name){
                        _.map( parentArea.children, ( child, i ) => {
                            if(child.name == request.area.name){
                                childArea = child;
                                selectedAreaDetail = child.data && child.data.areaDetails;
                            }
                        })
                    }
                    if(request.identifier && request.identifier.name){
                        _.map( childArea.children, ( subChild, i ) => {
                            if(subChild.name == request.identifier.name){
                                selectedAreaDetail = subChild.data && subChild.data.areaDetails;
                            }
                        })
                    }

                    if(selectedAreaDetail != null){
                        let unit = selectedAreaDetail.unit,
                            cost = parseInt(_.isEmpty(selectedAreaDetail.cost)?0:selectedAreaDetail.cost),
                            bookingIncreament = 0;
                        if(unit == 'Hours'){
                            bookingIncreament = selectedAreaDetail.hour.replace(/[^\d.-]/g, '');
                        } else if(unit == 'Days'){
                            bookingIncreament = selectedAreaDetail.day.replace(/[^\d.-]/g, '');
                        } else if(unit == 'Months'){
                            bookingIncreament = selectedAreaDetail.month.replace(/[^\d.-]/g, '');
                        } else if(unit == 'Weeks'){
                            bookingIncreament = selectedAreaDetail.week.replace(/[^\d.-]/g, '');
                        }
                        bookingIncreament = parseInt(_.isEmpty(bookingIncreament)?0:bookingIncreament)
                        request.costThreshold = (cost*bookingIncreament*(request.duration == "" ? 0 : parseFloat(request.duration))).toString();
                    }
                } else {
                    // request.costThreshold = '500';
                }
                let role = Meteor.user().getRole();
                if ( (role == 'staff' || role == 'tenant' || role == 'resident') && request.type != "Booking") {
                    return false;
                }
                return true;
            }
        },

        closeDetails: {
            type: "object",
            subschema: CloseDetailsSchema
        },

        invoiceDetails: {
            type: "object",
            subschema: InvoiceDetailsSchema
        },

        //////////////////////////////////////////////////
        // Dates & timing
        //////////////////////////////////////////////////

        dueDate: {
            type: "date",
            label: "Due/Start Date",
            description: "Latest date that the work can be completed",
            //input: DateTime,
            input: (props)=>{
                return props.item.type == "Schedular" || props.item.status == "Issued" ? <DateInput
                    {...props}
                    onChange ={(val)=>{
                        props.onChange(val)
                    }}
                /> :<DateTime
                    {...props}
                    onChange ={(val)=>{
                        props.onChange(val)
                    }}
                />
            },
            size: 6,
            required: true,
            defaultValue: getDefaultDueDate,
            condition: ( request ) => {
                if(request.type=='Booking'){
                    request.dueDate = ""
                    return false;
                }
                let role = Meteor.user().getRole();
                if ( _.contains( [ 'staff', 'resident', 'tenant' ], role ) /*&& request.type !='Booking'*/ ) {
                    return false;
                }
                if ( _.contains(['Incident','Booking'],request.type)) {
                    return false;
                }
                return true;
            }
        },

        incidenceDate: {
            type: "date",
            label: "When did it happen?",
            description: "The date and time the incident occured",
            input: DateTime,
            size: 6,
            required: true,
            defaultValue: getDefaultDueDate,
            condition: "Incident"
        },

        bookingPeriod: {
            type: "object",
            label: "Booking period",
            description: "Select the booking period",
            input: (props) => {
                let items = props.item;
                let bookableTimeSlot = null;
        		let previousBookingEvents = [];
        		let bookingFor = null
        		if(items && items.identifier && items.identifier.data){
        			if(items.identifier.data.areaDetails && items.identifier.data.areaDetails.daySelector){
        				bookableTimeSlot = items.identifier.data.areaDetails.daySelector;
        			}
        			if(items.identifier.totalBooking){
        				items.identifier.totalBooking.map((booking)=>{
                            let bookingFound;
                            if(!_.isEmpty(booking.bookingId)){
                                bookingFound = Requests.findOne({'_id':booking.bookingId,'status':'Booking'})
                                if(bookingFound && bookingFound.bookingPeriod && bookingFound.bookingPeriod.startTime && bookingFound.bookingPeriod.endTime){
                                    previousBookingEvents.push({
                						id:1,
                						title:items.identifier.name,
                						start:moment(bookingFound.bookingPeriod.startTime),
                						end:moment(bookingFound.bookingPeriod.endTime),
                						allDay:false,
                						editable:false,
                						color:"#ef6c00",
                						overlap:false,
                						tooltip:"Already Booked",
                					})
                                }
                            }
        				})
        			}
        			bookingFor = items.identifier.name
        		} else if(items && items.area && items.area.data) {
        			if(items.area.data.areaDetails && items.area.data.areaDetails.daySelector){
        				bookableTimeSlot = items.area.data.areaDetails.daySelector;
        			}
        			if(items.area.totalBooking){
        				items.area.totalBooking.map((booking)=>{
                            let bookingFound;
                            if(!_.isEmpty(booking.bookingId)){
                                bookingFound = Requests.findOne({'_id':booking.bookingId,'status':'Booking'})
                                if(bookingFound && bookingFound.bookingPeriod && bookingFound.bookingPeriod.startTime && bookingFound.bookingPeriod.endTime){
                                    previousBookingEvents.push({
                						id:1,
                						title:items.area.name,
                						start:moment(bookingFound.bookingPeriod.startTime),
                						end:moment(bookingFound.bookingPeriod.endTime),
                						allDay:false,
                						editable:false,
                						color:"#ef6c00",
                						overlap:false,
                						tooltip:"Already Booked",
                					})
                                }
                            }
        				})
        			}
                    bookingFor = items.area.name;
        		} else if(items && items.level && items.level.data) {
        			if(items.level.data.areaDetails && items.level.data.areaDetails.daySelector){
        				bookableTimeSlot = items.level.data.areaDetails.daySelector;
        			}
        			if(items.level.totalBooking){
        				items.level.totalBooking.map((booking)=>{
                            let bookingFound = 0;
                            if(!_.isEmpty(booking.bookingId)){
                                bookingFound = Requests.findOne({'_id':booking.bookingId,'status':'Booking'})
                                if(bookingFound && bookingFound.bookingPeriod && bookingFound.bookingPeriod.startTime && bookingFound.bookingPeriod.endTime){
                                    previousBookingEvents.push({
                						id:1,
                						title:items.level.name,
                						start:moment(bookingFound.bookingPeriod.startTime),
                						end:moment(bookingFound.bookingPeriod.endTime),
                						allDay:false,
                						editable:false,
                						color:"#ef6c00",
                						overlap:false,
                						tooltip:"Already Booked",
                					})
                                }
                            }
        				})
        			}
        			bookingFor = items.level.name;
        		}

        		let businessHours = [];

                let extra = moment().format('YYYY-MM-DD') + ' ';
        		let showSecondEvent = true
        		if(bookableTimeSlot && bookableTimeSlot.Sun && bookableTimeSlot.Sun.startTime && bookableTimeSlot.Sun.endTime && bookableTimeSlot.Sun.select == true){
        			showSecondEvent = true
        			if (moment(bookableTimeSlot.Sun.endTime).isBetween(moment(extra + '00:00'), moment(extra + '01:00'))){
        				showSecondEvent = false
        			}
        			businessHours.push({
        				dow: [ 0 ],
        				start: moment(bookableTimeSlot.Sun.startTime).format("HH:mm"),
        				end: moment(bookableTimeSlot.Sun.endTime).format("HH:mm"),
        				showSecondEvent:showSecondEvent
        			})
        		} else {
        			businessHours.push({
        				dow: [ 0 ],
        				start: '00:01',
        				end: '00:01',
        				showSecondEvent:true
        			})
        		}
        		if(bookableTimeSlot && bookableTimeSlot.Mon && bookableTimeSlot.Mon.startTime && bookableTimeSlot.Mon.endTime  && bookableTimeSlot.Mon.select == true){
        			showSecondEvent = true
        			if (moment(bookableTimeSlot.Mon.endTime).isBetween(moment(extra + '00:00'), moment(extra + '01:00'))){
        				showSecondEvent = false
        			}
        			businessHours.push({
        				dow: [ 1 ],
        				start: moment(bookableTimeSlot.Mon.startTime).format("HH:mm"),
        				end: moment(bookableTimeSlot.Mon.endTime).format("HH:mm"),
        				showSecondEvent:showSecondEvent
        			})
        		} else {
        			businessHours.push({
        				dow: [ 1 ],
        				start: '00:01',
        				end: '00:01',
        				showSecondEvent:true
        			})
        		}
        		if(bookableTimeSlot && bookableTimeSlot.Tue && bookableTimeSlot.Tue.startTime && bookableTimeSlot.Tue.endTime  && bookableTimeSlot.Tue.select == true){
        		    showSecondEvent = true
        			if (moment(bookableTimeSlot.Tue.endTime).isBetween(moment(extra + '00:00'), moment(extra + '01:00'))){
        				showSecondEvent = false
        			}
        			businessHours.push({
        				dow: [ 2 ],
        				start: moment(bookableTimeSlot.Tue.startTime).format("HH:mm"),
        				end: moment(bookableTimeSlot.Tue.endTime).format("HH:mm"),
        				showSecondEvent:showSecondEvent
        			})
        		} else {
        			businessHours.push({
        				dow: [ 2 ],
        				start: '00:01',
        				end: '00:01',
        				showSecondEvent:true
        			})
        		}
        		if(bookableTimeSlot && bookableTimeSlot.Wed && bookableTimeSlot.Wed.startTime && bookableTimeSlot.Wed.endTime  && bookableTimeSlot.Wed.select == true){
        			showSecondEvent = true
        			if (moment(bookableTimeSlot.Wed.endTime).isBetween(moment(extra + '00:00'), moment(extra + '01:00'))){
        				showSecondEvent = false
        			}
        			businessHours.push({
        				dow: [ 3 ],
        				start: moment(bookableTimeSlot.Wed.startTime).format("HH:mm"),
        				end: moment(bookableTimeSlot.Wed.endTime).format("HH:mm"),
        				showSecondEvent:showSecondEvent
        			})
        		} else {
        			businessHours.push({
        				dow: [ 3 ],
        				start: '00:01',
        				end: '00:01',
        				showSecondEvent:true
        			})
        		}
        		if(bookableTimeSlot && bookableTimeSlot.Thu && bookableTimeSlot.Thu.startTime && bookableTimeSlot.Thu.endTime  && bookableTimeSlot.Thu.select == true){
        			showSecondEvent = true
        			if (moment(bookableTimeSlot.Thu.endTime).isBetween(moment(extra + '00:00'), moment(extra + '01:00'))){
        				showSecondEvent = false
        			}
        			businessHours.push({
        				dow: [ 4 ],
        				start: moment(bookableTimeSlot.Thu.startTime).format("HH:mm"),
        				end: moment(bookableTimeSlot.Thu.endTime).format("HH:mm"),
        				showSecondEvent:showSecondEvent
        			})
        		} else {
        			businessHours.push({
        				dow: [ 4 ],
        				start: '00:01',
        				end: '00:01',
        				showSecondEvent:true
        			})
        		}
        		if(bookableTimeSlot && bookableTimeSlot.Fri && bookableTimeSlot.Fri.startTime && bookableTimeSlot.Fri.endTime  && bookableTimeSlot.Fri.select == true){
        			showSecondEvent = true
        			if (moment(bookableTimeSlot.Fri.endTime).isBetween(moment(extra + '00:00'), moment(extra + '01:00'))){
        				showSecondEvent = false
        			}
        			businessHours.push({
        				dow: [ 5 ],
        				start: moment(bookableTimeSlot.Fri.startTime).format("HH:mm"),
        				end: moment(bookableTimeSlot.Fri.endTime).format("HH:mm"),
        				showSecondEvent:showSecondEvent
        			})
        		} else {
        			businessHours.push({
        				dow: [ 5 ],
        				start: '00:01',
        				end: '00:01',
        				showSecondEvent:true
        			})
        		}
        		if(bookableTimeSlot && bookableTimeSlot.Sat && bookableTimeSlot.Sat.startTime && bookableTimeSlot.Sat.endTime  && bookableTimeSlot.Sat.select == true){
        			showSecondEvent = true
        			if (moment(bookableTimeSlot.Sat.endTime).isBetween(moment(extra + '00:00'), moment(extra + '01:00'))){
        				showSecondEvent = false
        			}
        			businessHours.push({
        				dow: [ 6 ],
        				start: moment(bookableTimeSlot.Sat.startTime).format("HH:mm"),
        				end: moment(bookableTimeSlot.Sat.endTime).format("HH:mm"),
        				showSecondEvent:showSecondEvent
        			})
        		} else {
        			businessHours.push({
        				dow: [ 6 ],
        				start: '00:01',
        				end: '00:01',
        				showSecondEvent:true
        			})
        		}
        		let bookingDetails = {
        			businessHours:businessHours,
        			previousBookingEvents:previousBookingEvents,
        			bookingFor:bookingFor
        		};
                return  <CalendarPeriod
                            onChangeValue={(value)=>{
                                props.onChange(value);
                            }}
                            bookingDetails = {bookingDetails}
                            {...props}
                        />
            },

            size: 12,
            required: true,
            defaultValue: {},
            condition: (request)=>{
                if(request.type == "Booking" && request.level && request.level.name){
                    if(request.bookingPeriod && request.bookingPeriod.startTime && request.bookingPeriod.endTime){
                        let duration = moment.duration(moment(request.bookingPeriod.endTime).diff(moment(request.bookingPeriod.startTime)));
                        let hours = duration.asHours();
                        request.duration = hours.toString();
                    } else {
                        request.duration = ''
                    }
                    return true;
                } else {
                    return false;
                }
            }
        },

        issuedAt: {
            type: "date",
            label: "Issued date",
            description: "Date and time that the job was issued",
            input: DateTime,
            size: 6,
            required: true,
            defaultValue: ""
        },

        eta: {
            label: "ETA",
            description: "Time the supplier is expected to attend the site",
            size: 6,
            required: true,
            type: "date",
            input: DateTime,
            defaultValue: ""
        },

        //////////////////////////////////////////////////
        // Relations
        // Should be defined here in the schema and implemented automatically
        //////////////////////////////////////////////////

        team: {
            label: "Client",
            description: (item)=>{
                let workRequest = "work";
                if(!_.isEmpty(item.type)){
                    workRequest = item.type
                }
                return "The team who created this"+ workRequest +"request";
            },
            type: "object",
            input: Select,
            options: ( item ) => {
                let team = Session.getSelectedTeam();
                return {
                    items: Teams.isServiceTeam( team ) ? team.getClients() : null,
                    view: ContactCard
                }
            },
            defaultValue: ( item ) => {
                let team = Session.getSelectedTeam();
                if ( Teams.isFacilityTeam( team ) ) {
                    return team;
                }
            }
        },

        facility: {
            label: "Site Address",
            description: "The site for this job",
            type: "object",
            required: true,
            defaultValue: ( request ) => {
                let team = Teams.collection._transform( request.team ),
                    facilities = team.getFacilities( { 'team._id': request.team._id } );
                if ( facilities.length == 1 ) {
                    return facilities[ 0 ];
                }
                // return the selected facility.
                return Session.getSelectedFacility();
            },

            input: Select,

            options: ( request ) => {
                let team = Teams.findOne( request.team._id ),
                    role = Meteor.user().getRole(),
                    facilities = team.getFacilities( { 'team._id': request.team._id } );
                /*
                import { Facilities } from '/modules/models/Facilities';
                let facilities = Facilities.findAll( { 'team._id': request.team._id } );
                */
                return {
                    items: facilities,
                    view: FacilityListTile,

                    afterChange: ( request ) => {
                        if ( request == null ) {
                            return;
                        }
                        request.level = null;
                        request.area = null;
                        request.identifier = null;
                        request.service = null;
                        request.subservice = null;
                        request.supplier = null;
                        request.members = ( _.filter( request.members, m => m.role !== defaultContactRole ) );
                    },
                    addNew: {
                        //Add new facility to current selectedTeam.
                        show: !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ), //Meteor.user().getRole() != 'staff',
                        label: "Create New",
                        onAddNewItem: ( callback ) => {
                            import { Facilities, FacilityStepperContainer } from '/modules/models/Facilities';
                            let team = Session.getSelectedTeam(),
                                facility = Facilities.create( { team } );
                            facility = Facilities.collection._transform( facility );
                            Modal.show( {
                                content:
                                    <FacilityStepperContainer params = {
                                        {
                                            item: facility,
                                            onSaveFacility:
                                                ( facility ) => {
                                                    callback( facility );
                                                }
                                        }
                                    }
                                />
                            } )
                        }
                    },
                }
            },
            condition: ( request ) => {
                //do not show this field if number of facilities is one or less
                let team = request.team && request.team._id ? Teams.findOne( request.team._id ) : Session.getSelectedTeam(),
                    facilities = team.getFacilities( { 'team._id': team._id } );
                if ( facilities.length <= 1 || request.type == 'Booking' ) {
                    return false;
                }
                return true;
            }
        },

        supplier: {
            label: "Supplier",
            description: "The supplier who has been assigned to this job",
            type: "object",
            relation: {
                type: ORM.HasOne,
                source: Teams,
            },
            condition: ( request ) => {

                let team = Session.getSelectedTeam();
                if ( request.type == 'Incident' ) {
                    return false;
                }
                //do not show for booking, contractors, staff or resident
                if( request.type != 'Booking' ) {
                    if( Teams.isFacilityTeam( team ) ) {
                        if( !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ) ) {
                            return true;
                        }
                    }
                }
                return false;

            },
            defaultValue: ( item ) => {
                let team = Session.getSelectedTeam();
                /*if ( item.type == 'Incident' ) {
                    return team;
                }*/
                if( Teams.isServiceTeam( team ) ) {
                    return team;
                }
            },
            input:( props ) => {
                return <Select {...props}
                    onChange={( value ) => {
                        let team = Session.getSelectedTeam();
                        let costAbleToIssue = true;
                        if(team.defaultCostThreshold){
                            costAbleToIssue = false;
                            let actualCost = props.item.hasOwnProperty("costThreshold") ? props.item.costThreshold.replace(/,/g, "") : "";
                                actualCost = _.isEmpty(actualCost) ? 0 : parseFloat(actualCost)
                            costAbleToIssue = actualCost <= team.defaultCostThreshold ? true : false;
                        }
                        onServiceChange = costAbleToIssue == true ? props.changeSubmitText(value) : props.changeSubmitText(null)
                        props.onChange(value);
                    }}/>
            } ,
            options: ( item ) => {
                let facility = null,
                    supplier = null,
                    role = Meteor.user().getRole();

                if ( item.facility && item.facility._id ) {
                    facility = Facilities.findOne( item.facility._id );
                    /*if( facility ) {
                        console.log( facility.getSuppliers() );
                    }*/
                }

                return {
                    items: facility && facility.getSuppliers ? facility.getSuppliers() : null,
                    view: ContactCard,
                    readOnly: item.status == 'Issued',
                    addNew: {
                        //Add new supplier to request and selected facility.
                        show: !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ), //Meteor.user().getRole() != 'staff',
                        label: "Create New",
                        onAddNewItem: ( callback ) => {
                            import { TeamStepper } from '/modules/models/Teams';
                            Modal.show( {
                                content: <TeamStepper item = { supplier }
                                facility = { facility }
                                onChange = {
                                    ( supplier ) => {
                                        facility.addSupplier( supplier );
                                        callback( supplier );
                                    }
                                }
                                />
                            } )
                        }
                    },
                    afterChange: ( request, supplier ) => {
                        if( !supplier ) {
                            request.supplierContacts = [];
                        }
                        else if ( Teams.isFacilityTeam( supplier ) ) {
                            request.supplierContacts = supplier.getMembers( { role: 'portfolio manager' } );
                        } else {
                            request.supplierContacts = supplier.getMembers( { role: 'manager' } );
                        }
                    }
                }
            },
        },

        supplierContacts: {
            label: "Supplier contacts",
            type: 'array',
            size: 12
        },

        supplierContact: {
            label: 'Supplier contact',
            type: 'string',
            size: 12,
            condition: ( request ) => {
                let selectedTeam = Session.get( 'selectedTeam' );
                //do not show for booking, contractors, staff or resident
                return (
                    (
                        request.status != 'Issued' &&
                        !_.contains(['Booking','Incident'],request.type) &&
                        //Teams.isServiceTeam( selectedTeam )
                        Teams.isFacilityTeam( selectedTeam )
                    ) ?
                    ( !_.contains( [ 'staff', 'resident', 'tenant' ], Meteor.user().getRole() ) ) : false
                )
            },
            input( props ) {
                if ( !props.item.supplierContacts ) {
                    props.item.supplierContacts = [];
                }
                // this should be in it's own component
                return (
                        <div className="row">
                    <div className="col-xs-12">
                        <Select
                            placeholder     = "Supplier contact"
                            items           = {props.items}
                            Model           = {props.Model}
                            view            = {props.view}
                            item            = {props.item}
                            onChange        = { ( val ) => {
                                let memberExists = props.item.supplierContacts.find( ( contact ) => {
                                    return contact._id === val._id;
                                } );
                                if ( !memberExists) {
                                    props.item.supplierContacts.push( {
                                        _id: val._id,
                                        name: val.name || val.profile.name,
                                        role: defaultContactRole,
                                        email: val.profile.email,
                                    } );
                                    props.onChange( "" );
                                }
                            } }
                        />
                    </div>
                    <div className="col-xs-12">
                        {_.map( props.item.supplierContacts, ( sc, i ) => (
                            <div className="col-sm-5" key={i}
                                style={{
                                    backgroundColor: 'aliceblue',
                                    padding: '5px',
                                    border: '1px solid transparent',
                                    borderRadius: '5px',
                                    margin: '5px',
                                    borderLeft: '4px solid aquamarine',
                                }}>
                                <span onClick={() => {
                                        let id = sc._id,
                                            newValue =  _.filter( props.item.supplierContacts,  v => v._id !== id );
                                        props.item.supplierContacts = newValue;
                                        props.onChange( "" );
                                    }}
                                    style={{
                                        float: 'right',
                                        cursor: 'pointer',
                                        fontSize: '14px',
                                        fontWeight: 'bold',
                                        marginRight: '0px',
                                        marginTop: '-6px',
                                    }} title="Remove tag">&times;</span>
                                <ContactCard item={sc} team={props.team} group={props.group} />
                            </div>))}
                    </div> </div>)
                    },
                    options( item ) {
                        let supplier = null,
                            members = [];
                        if ( item.supplier ) {
                            let query = {};
                            item.supplier._id ? ( query._id = item.supplier._id ) : ( query.name = item.supplier.name );
                            supplier = Teams.findOne( query );
                        }
                        if ( supplier && supplier.members ) {
                            ids = _.pluck( supplier.members, '_id' );
                            members = Users.findAll( { _id: { $in: ids } } );
                        }
                        return {
                            readOnly: item.status == 'Issued',
                            items: members,
                            view: ContactCard
                        }
                    }
            },

            assignee: {
                label: "Assignee",
                description: "The individual who has been allocated to this job",
                condition: ( request ) => {
                    /*if ( request.supplier && request.supplier._id ) {
                        let team = Session.getSelectedTeam();
                        if( team._id == request.supplier._id ) {
                            let userRole = Meteor.user().getRole();
                            if( _.contains( [ 'portfolio manager', 'manager' ], userRole ) ) {
                                return true;
                            }
                        }
                    }
                    return false;*/
                    let role = Meteor.user().getRole();
                    if (role == 'caretaker' || role == 'staff' || role == 'resident' || role == 'tenant' ) {
                        return false;
                    }
                    let team = Session.getSelectedTeam();
                    if ( request.supplier && ( team._id == request.supplier._id || team.name == request.supplier.name ) ) {
                        return true;
                    }
                    if(_.contains( [ "portfolio manager", 'manager'], role )){
                        return true;
                    }
                    return false;
                },
                input: Select,
                type: "object",
                options: ( request ) => {
                    request = Requests.collection._transform( request );

                    let members = null,
                        supplier = null;

                    if( request.supplier && request.supplier._id ) {
                        let supplier = Teams.findOne( request.supplier._id );
                        if( supplier ) {
                            members = supplier.getMembers();
                        }
                    }

                    return {
                        items: members,
                        view: ContactCard,
                        addNew: {
                            //Add new facility to current selectedTeam.
                            show: Meteor.user().getRole() != 'staff',
                            label: "Add New",
                            onAddNewItem: ( callback ) => {
                                import { Users, UserViewEdit } from '/modules/models/Users';
                                if( supplier ) {
                                    Modal.show( {
                                        content: <UserViewEdit group={ supplier } team={ supplier } addPersonnel={ ( newAssignee ) => callback( newAssignee ) }/>
                                    } )
                                }
                            }
                        },
                        afterChange: ( item ) => {
                            if( !item.members ) {
                                item.members = [];
                            }
                            let found = false;
                            if ( item.assignee && item.assignee._id ) {

                                import { Users } from '/modules/models/Users';

                                let assignee = Users.findOne( item.assignee._id );

                                for ( i in item.members ) {
                                    let member = item.members[ i ];
                                    if ( member.role == "assignee" ) {
                                        item.members[ i ] = {
                                            _id: assignee._id,
                                            name: assignee.profile.name,
                                            role: "assignee"
                                        };
                                        found = true;
                                        break;
                                    }
                                }
                                if ( !found ) {
                                    item.members.push( {
                                        _id: assignee._id,
                                        name: assignee.profile.name,
                                        role: "assignee"
                                    } );
                                }
                            }
                        }
                    }
                },
            },

            members: {
                label: "Contacts",
                description: (item)=>{
                    let workRequest = "work";
                    if(!_.isEmpty(item.type)){
                        workRequest = item.type
                    }
                    return "Stakeholders for this"+ workRequest +"request";
                },
            },

            documents: {
                label: "Documents",
                description: "Saved request documents",
                type: "array",
                /*relation:
                {
                    type: ORM.HasMembers,
                    source: "Files",
                    key: "team._id"
                },*/
                input: DocExplorer
            },

            attachments: {
                label: "Attachments",
                type: "array",
                input: FileExplorer
            },

            //////////////////////////////////////////////////
            //}

            requireServiceReport: {
                label: "Require Service Report",
                type: "boolean",
                defaultValue: false,
                input: Switch,
                condition: () => {
                    let role = Meteor.user().getRole();
                    return _.indexOf( [ "manager", "portfolio manager", "team portfolio manager", "team manager" ], role ) > -1;
                }
            },

            requireInvoice: {
                label: "Require Invoice",
                type: "boolean",
                defaultValue: false,
                input: Switch,
                condition: () => {
                    let role = Meteor.user().getRole();
                    return _.indexOf( [ "manager", "portfolio manager", "team portfolio manager", "team manager" ], role ) > -1;
                }
            },

            memberName: {
                type: "string",
                label: "Member name",
                description: "Name of member",
                input: Text,
                size: 6,
                required: true,
                defaultValue: (item)=>{
                    return item.type == 'Booking' ? Meteor.user().getName() : null;
                },
                condition:"Booking"
            },

            numberOfPersons: {
                type: "number",
                label: "Number of persons",
                description: "Number of persons",
                input: Text,
                size: 6,
                required: true,
                condition:"Booking"
            },

            footer: {
                size: 12,
                input( props ) {
                    let period
                    if ( props.item.frequency.period ) {
                        switch ( props.item.frequency.period ) {
                            case "daily":
                                period = "day"
                                break;
                            case "fortnightly":
                                period = "fortnight"
                                break;
                            case "weekly":
                                period = "week"
                                break;
                            case "monthly":
                                period = "month"
                                break;
                            case "quarterly":
                                period = "quarter"
                                break;
                            case "annually":
                                period = "year"
                                break;
                            default:

                        }
                        period = period || props.item.frequency.period;
                        period = formatSingularPlural(period);
                    }
                    return (
                        <div style={{paddingTop: "10%", fontWeight:"500",fontSize:"16px"}}>
                            {props.item.frequency.number && props.item.frequency.period && props.item.frequency.endDate?
                                <div>
                                    {`Repeats every ${props.item.frequency.number} ${period} until ${moment(props.item.frequency.endDate).format("D MMMM YYYY")}`}
                                </div>:(
                                    props.item.frequency.number && props.item.frequency.period ?
                                    <div>
                                        {`Repeats every ${props.item.frequency.number} ${period} until stopped`}
                                    </div>:(
                                        props.item.frequency.period && props.item.frequency.endDate?
                                        <div>
                                            {props.item.frequency.endDate?`Repeats ${formatSingularPlural(props.item.frequency.period)} until ${moment(props.item.frequency.endDate).format("D MMMM YYYY")}`:null}
                                        </div>:
                                        <div>
                                            {props.item.frequency.unit?`Repeats ${props.item.frequency.period?formatSingularPlural(props.item.frequency.period):null || formatSingularPlural(props.item.frequency.unit)} until stopped`:null}
                                        </div>
                                    )
                                )
                            }
                        </div>
                    );
                },
                condition: "Schedular",
            }

        }


        function getTimeframe( _id, priority ) {
            //let team = this.getTeam();
            let team = Teams.findOne( { _id: _id } );
            if ( team ) {
                return team.getTimeframe( priority );
            }
        }

        function getJobCode( item ) {
            let team = null,
                code = 0;

            if ( item && item.team ) {
                team = Teams.findOne( {
                    _id: item.team._id
                } );
                code = team.getNextWOCode();
            }

            return code;
        }

        function getDefaultDueDate( item ) {
            if ( !item.team ) {
                return new Date();
            }
            let team = Teams.findOne( item.team._id ),
                timeframe = team.timeframes[ 'Standard' ] * 1000,
                now = new Date();

            return new Date( now.getTime() + timeframe );
        }

        function getRole() {
            return RBAC.getRole( Meteor.user(), Session.getSelectedTeam() );
        }

        function formatSingularPlural(str) {
            if (str.slice(-1)=='s') {
                str =  str.substring(0, str.length-1)+"(s)";
            }
            return str;
        }

        export default PPMSchema;
